#!/usr/bin/env python3

import argparse
import os
import subprocess
import time

SIGNALS = [
    (15, 3),
    (2, 3),
    (1, 4),
    (9, 0),
]


def is_int(arg):
    try:
        return int(arg) != 0
    except ValueError:
        return False


def running(pid):
    result = subprocess.run(["ps", "-p", str(pid)], capture_output=True, text=True)
    return len(result.stdout.strip().splitlines()) == 2


def go_ahead():
    return input().strip().lower() in {"y", "yes", "yas"}


def kill(pid, code):
    subprocess.run(["kill", f"-{code}", str(pid)], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def murder_pid(pid):
    for code, wait in SIGNALS:
        if not running(pid):
            break
        kill(pid, code)
        time.sleep(0.5)
        if running(pid):
            time.sleep(wait)


def murder_names(name):
    should_continue = True
    while should_continue:
        should_continue = False
        result = subprocess.run(
            ["ps", "-eo", "pid,command"], capture_output=True, text=True
        )
        lines = [
            line for line in result.stdout.splitlines() if name.lower() in line.lower()
        ]
        lines = [line for line in lines if "grep" not in line]

        for line in lines:
            parts = line.split(None, 1)
            if len(parts) < 2:
                continue
            pid, fullname = parts
            if os.getpid() == int(pid):
                continue
            print(f"murder {fullname.strip()} (pid {pid})? ", end="")
            if go_ahead():
                murder_pid(pid)
                should_continue = True
                break


def murder_port(port):
    should_continue = True
    while should_continue:
        should_continue = False
        result = subprocess.run(["lsof", "-i", port], capture_output=True, text=True)
        lines = result.stdout.splitlines()[1:]  # skip header
        for line in lines:
            parts = line.split(None, 3)
            if len(parts) < 2:
                continue
            pid = parts[1]
            ps_result = subprocess.run(["ps", "-p", pid, "-o", "command="], capture_output=True, text=True)
            fullname = ps_result.stdout.strip()
            print(f"murder {fullname} (pid {pid})? ", end="")
            if go_ahead():
                murder_pid(pid)
                should_continue = True
                break


def murder(arg):
    is_pid = is_int(arg)
    is_port = arg.startswith(":") and is_int(arg[1:])
    if is_pid:
        murder_pid(arg)
    elif is_port:
        murder_port(arg)
    else:
        murder_names(arg)


def main():
    parser = argparse.ArgumentParser(
        description="Gracefully terminate processes by PID, name, or port.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog=(
            "Examples:\n"
            "  murder 123        Kill process by PID\n"
            "  murder ruby       Kill all processes matching name 'ruby'\n"
            "  murder :3000      Kill process bound to port 3000\n"
        ),
    )

    parser.add_argument(
        "targets",
        nargs="+",
        help="Process identifier(s): PID, process name, or :<port> notation.",
    )

    args = parser.parse_args()

    for arg in args.targets:
        murder(arg)


if __name__ == "__main__":
    main()
